<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Overbrowsing</title>
  <meta name="description" content="Overbrowsing: dedicated to fostering a deeper understanding of sustainable web design.">
  <meta property="og:title" content="Overbrowsing">
  <meta property="og:description" content="Overbrowsing: dedicated to fostering a deeper understanding of sustainable web design.">
  <meta property="og:image" content="https://overbrowsing.com/assets/share-card.webp">
  <meta property="og:url" content="https://overbrowsing.com">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸŒŽ</text></svg>">
  <link rel="stylesheet" href="./style.css">
</head>
  <body style="background-color: #272a24">
    <nav>
        <div class="nav-container">
        <div class="nav-about">
            <p><b>Overbrowsing</b> compiles sustainable web design resources, tools, strategies, principles, and other related media. The term Overbrowsing carries a <a href="https://en.wikipedia.org/wiki/Browsing_(herbivory)#:~:text=Overbrowsing%20occurs%20when%20overpopulated%20or%20densely-concentrated%20herbivores%20exert%20extreme%20pressure%20on%20plants,%20reducing%20the%20carrying%capacity%20and%20altering%20the%20ecological%20functions%20of%20their%20habitat." target="_blank">dual meaning</a> that aligns with the core mission of the initiative.</p>
            <p>This is a low-consumption site that uses just NaNg CO2e and runs on clean energy.</p>
            <p>The website background changes color based on air quality. Today, the air quality is good.</p>
            <p>Overbrowsing is <a href="https://are.na/are-na/powered-by-are-na" target="_blank">Powered by Are.na</a> and employs techniques and principles to make it low-consumption. See our <a href="https://github.com/overbrowsing/overbrowsing.com" target="_blank">Github</a> to find out more about the construction of this website.</p>
            <p>The project was created by <a href="https://headless.horse" target="_blank">Headless Horse</a> and <a href="https://printerscanner.net" target="_blank">printer_scanner</a>.</p>
        </div>
        <div class="nav-links">
            <a href="/">Graph</a>
            <a href="/feed">Research</a>
            <a href="/about">About</a>
        </div>
        
    </nav>
    
  
    <script defer src="https://d3js.org/d3.v5.min.js"></script>
    <style>


    @keyframes dash {
      to {
        stroke-dashoffset: 1000;
      }
    }

  .node circle {
    /* Your existing styles */
    stroke: #ABB193;
    stroke-width: 2px;
    fill: #272A24;
    transition: fill 0.3s ease;
  }

  .node:hover circle {
    fill: #4CAF50; /* Change the fill color on hover */
  }

.link {
  /* Your existing styles */
  fill: none;
  stroke: #ABB193;
  stroke-width: 1px;
  stroke-dasharray: 3 3;
  display: none;
  transition: stroke 0.3s ease;
  pointer-events: auto; /* Enable pointer events */
}

  .link-hover {
    stroke-width: 2px;
    animation: dash 60s linear; 
  }

  .node text {
    /* Your existing styles */
    font-size: 12px;
    fill: #ABB193 !important;
    text-anchor: middle;
    pointer-events: none;
    max-width: 100px;
  }

  .node {
    display: none
  }

  .root {
    display: block
  }


  .hidden {
    display: none;
  }

  svg {
    width: 100%;
    height: 100%;
  }
    </style>
    <script defer>


      fetch('data/data.json')
        .then(res => res.json())
        .then(data => {
          const restructuredData = {
            id: 'Overbrowsing',
            title: 'Overbrowsing',
            children: [],
          };

          const groupedByCategory = {};

          data.forEach(categoryNode => {
            const category = categoryNode.category || 'Uncategorized';
            if (!groupedByCategory[category]) {
              groupedByCategory[category] = [];
            }
            groupedByCategory[category].push(categoryNode);
          });

          for (const [category, items] of Object.entries(groupedByCategory)) {
            const categoryNode = {
              id: category.replace(/\s+/g, '-'),
              title: category.replace(/\s+/g, '-'),
              children: [],
            };

            items.forEach(item => {
              if (item.contents) {
                const contentCategoryNode = {
                  id: item.title.replace(/\s+/g, '-'),
                  title: item.title,
                  children: item.contents,
                };
                categoryNode.children.push(contentCategoryNode);
              } else {
                categoryNode.children.push(item);
              }
            });

            restructuredData.children.push(categoryNode);
          }

          const pageWidth = document.documentElement.clientWidth;
          const pageHeight = document.documentElement.clientHeight;

          const svg = d3.select('body').append('svg');


          const simulation = d3.forceSimulation()
            .force('link', d3.forceLink().id(d => d.id).distance(200))
            .force('charge', d3.forceManyBody())
            .force('center', d3.forceCenter(pageWidth / 2, pageHeight / 2));

          const flatten = (root) => {
            const nodes = [];
            const links = [];

            const recurse = (node, parent) => {
              if (node.children) {
                node.children.forEach(child => {
                  if (child.title) { // Check if the child has a title
                    links.push({ ...node, source: node.id, target: child.id });
                    recurse(child, node);
                  }
                });
              }
              nodes.push({ ...node, parent });
            };

            recurse(root, null);

            return { nodes, links };
          };

          const { nodes, links } = flatten(restructuredData);

          const link = svg.selectAll('.link')
              .data(links)
              .enter().append('path')
              .attr('class', 'link')
              .attr('data-id', d => d.target.id) // Set the data-id attribute to the child's ID
          
          const node = svg.selectAll('.node')
            .data(nodes)
            .enter().append('g')
            .attr('class', d => (d.id === 'Overbrowsing' ? 'node root' : 'node')) // Add 'root' class for the root node
            .attr('data-id', d => d.id) // Set the data-id attribute
            .attr('data-parent', d => (d.parent ? d.parent.id : null)) // Set the data-parent attribute
            .on('click', clicked)
            .on('mouseover', handleMouseOver)
            .on('mouseout', handleMouseOut)
            .call(d3.drag()
              .on('start', dragstarted)
              .on('drag', dragged)
              .on('end', dragended));

          // Append circles only for nodes with children
          node.filter(d => d.children)
            .append('circle')
            .attr('r', 75);

          node.append('text')
            .attr('dy', 10)
            .attr('color', 'white')
            .style('overflow', 'visible') // Allow text to overflow
            .text(d => d.children ? `${d.title} Â· ${d.children.length}` : d.title);


          simulation.nodes(nodes).on('tick', () => {
            link
              .attr('data-id', d => d.target.id) // Update the data-id attribute to the child's ID
              .attr('d', d => `M${d.source.x},${d.source.y} L${d.target.x},${d.target.y}`)

            node
              .attr('transform', d => `translate(${d.x},${d.y})`);
          });

          simulation.force('link').links(links);

          function dragstarted(d) {
            if (!d3.event.active) simulation.alphaTarget(0.7).restart(); // Set a lower alphaTarget when drag starts
            d.fx = d.x;
            d.fy = d.y;
          }

          function dragged(d) {
            d.fx = d3.event.x;
            d.fy = d3.event.y;
          }

          function dragended(d) {
            if (!d3.event.active) simulation.alphaTarget(1); // Set alphaTarget back to 1 when drag ends
            d.fx = null;
            d.fy = null;
          }

          function clicked(d) {
            toggle(d);
          }

          function handleMouseOver(d) {
            // Find the corresponding link and apply hover styles
            d3.select(this).select('circle').transition().duration(300).attr('r', 80);

            const correspondingLink = document.querySelector(`.link[data-id="${d.id}"]`);
              
            if (correspondingLink) {
              correspondingLink.classList.add("link-hover")
            }
          }
          function handleMouseOut(d) {
            d3.select(this).select('circle').transition().duration(300).attr('r', 75);

            // Revert styles on mouseout
            const correspondingLink = document.querySelector(`.link[data-id="${d.id}"]`);
              
            if (correspondingLink) {
              correspondingLink.classList.remove("link-hover")
            }
          }

          function toggle(node) {
            if (node.children) {
              node.children.forEach(child => {
                if (child.title) {
                const childElements = svg.selectAll(`g[data-id="${child.id}"]`);
                const childLinks = svg.selectAll(`.link[data-id="${child.id}"]`);

                if (childElements.node()) {
                  const dataParentValue = childElements.attr('data-parent');
                  const parentElement = svg.select(`g[data-id="${dataParentValue}"]`);

                  // Check if the parentElement is visible before toggling child elements
                  if (parentElement.style('display') == 'none') { 
                    childElements.style('display', 'none');
                    childLinks.style('display', 'none');
                  } else {
                    childElements.style('display', childElements.style('display') === 'none' ? 'block' : 'none');
                    childLinks.style('display', childLinks.style('display') === 'none' ? 'block' : 'none');
                  }
                }
                if (childElements.style('display') == 'none') {
                  toggle(child); // Recursively toggle visibility for child nodes
                }
                }
              });
            }
          }
        });
    </script>
  
    
    </body>
</html>