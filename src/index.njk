{% extends 'layout.njk' %}
{% block content %}
  {% block scripts %}
    <script defer src="https://d3js.org/d3.v5.min.js"></script>
    <style>
      .node circle {
        stroke: #ABB193;
        stroke-width: 2px;
        fill: #272A24;
      }

      .link {
        fill: none;
        stroke: #ABB193;
        stroke-width: 1px;
        display: block;
      }

      .node text {
        font-size: 12px;
        fill: #ABB193 !important;
        text-anchor: middle;
        pointer-events: none; /* Prevent text selection while dragging */
        max-width: 100px
      }


      .hidden {
        display: none;
      }
    </style>
    <script defer>


      fetch('data/data.json')
        .then(res => res.json())
        .then(data => {
          const restructuredData = {
            id: 'Overbrowsing',
            title: 'Overbrowsing',
            children: [],
          };

          const groupedByCategory = {};

          data.forEach(categoryNode => {
            const category = categoryNode.category || 'Uncategorized';
            if (!groupedByCategory[category]) {
              groupedByCategory[category] = [];
            }
            groupedByCategory[category].push(categoryNode);
          });

          for (const [category, items] of Object.entries(groupedByCategory)) {
            const categoryNode = {
              id: category.replace(/\s+/g, '-'),
              title: category.replace(/\s+/g, '-'),
              children: [],
            };

            items.forEach(item => {
              if (item.contents) {
                const contentCategoryNode = {
                  id: item.title.replace(/\s+/g, '-'),
                  title: item.title,
                  children: item.contents,
                };
                categoryNode.children.push(contentCategoryNode);
              } else {
                categoryNode.children.push(item);
              }
            });

            restructuredData.children.push(categoryNode);
          }

          const width = 1000;
          const height = 1000;

          const svg = d3.select('body').append('svg')
            .attr('width', width)
            .attr('height', height);

          const simulation = d3.forceSimulation()
            .force('link', d3.forceLink().id(d => d.id).distance(100))
            .force('charge', d3.forceManyBody())
            .force('center', d3.forceCenter(width / 2, height / 2));

          const flatten = (root) => {
            const nodes = [];
            const links = [];

            const recurse = (node, parent) => {
              if (node.children) {
                node.children.forEach(child => {
                  links.push({ ...node, source: node.id, target: child.id });
                  recurse(child, node);
                });
              }
              nodes.push({ ...node, parent });
            };

            recurse(root, null);

            return { nodes, links };
          };

          const { nodes, links } = flatten(restructuredData);

          const link = svg.selectAll('.link')
            .data(links)
            .enter().append('path')
            .attr('class', 'link')

          const node = svg.selectAll('.node')
            .data(nodes)
            .enter().append('g')
            .attr('class', 'node')
            .attr('data-id', d => d.id) // Set the data-id attribute
            .on('click', clicked)
            .call(d3.drag()
              .on('start', dragstarted)
              .on('drag', dragged)
              .on('end', dragended));

          // Append circles only for nodes with children
          node.filter(d => d.children)
            .append('circle')
            .attr('r', 50);

          node.append('text')
            .attr('dy', 5)
            .attr('color', "white")
            .text(d => d.title);

          simulation.nodes(nodes).on('tick', () => {
            link
              .attr('data-id', d => d.id) // Set the data-id attribute
              .attr('d', d => `M${d.source.x},${d.source.y} L${d.target.x},${d.target.y}`)


            node
              .attr('transform', d => `translate(${d.x},${d.y})`);
          });

          simulation.force('link').links(links);

          function dragstarted(d) {
            if (!d3.event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
          }

          function dragged(d) {
            d.fx = d3.event.x;
            d.fy = d3.event.y;
          }

          function dragended(d) {
            if (!d3.event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
          }

          function clicked(d) {
            toggleVisibility(d);
            update();
          }

// Set the initial display property to none for each element

          function toggleVisibility(node) {
            if (node.children) {
              node.children.forEach(child => {
                const childElements = svg.selectAll(`g[data-id="${child.id}"]`);
                if (childElements.node()) {
                  childElements.style('display', childElements.style('display') === 'none' ? 'block' : 'none');
                }
                toggleVisibility(child); // Recursively toggle visibility for child nodes
              });
              
              // Toggle visibility for associated links
              const childLinks = document.querySelectorAll(`.link[data-id="${node.id}"]`);
              childLinks.forEach(child => {
                if (child.style.display !== "none") {
                  child.style.display = "none";
                } else {
                  child.style.display = "block";
                }
              });

              toggleVisibility(node.children); // Recursively toggle visibility for child links
            }
          }

          function update() {
            // Update any additional visual elements as needed
          }
        });
    </script>
  {% endblock %}
{% endblock %}
